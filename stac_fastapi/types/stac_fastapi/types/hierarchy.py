"""Types and functions for browseable and children conformance class support.

The types contained in this file provide the tooling necessary to support hierarchy within a
STAC API. The various nodes are recursively parsed from a dict which can (e.g.) be generated by
json.load. A minimal, STAC compliant catalog can be generated from a catalog node (refer to a
node's id field name: it will either be catalog_id or collection_id) with the browseable_catalog
function.
"""
from typing import List, Optional, Tuple, TypedDict, Union
from urllib.parse import urljoin

from stac_pydantic.links import Relations
from stac_pydantic.shared import MimeTypes

from stac_fastapi.types import stac as stac_types

ItemPath = Tuple[str, str]


class BrowseableNode(TypedDict):
    """Abstract node for defining browseable hierarchy."""

    children: List[Union["CatalogNode", "CollectionNode"]]
    items: List[ItemPath]


class CollectionNode(BrowseableNode):
    """Node for collections in browseable hierarchy."""

    collection_id: str


class CatalogNode(BrowseableNode):
    """Node for collections in browseable hierarchy."""

    catalog_id: str
    title: Optional[str]
    description: Optional[str]


# PGSTAC TODO: function to look up catalog (could be as simple as selecting
# 'where catalog_id = full/catalog/path' which implementers will have to sort out)
def find_catalog(
    hierarchy: BrowseableNode, split_path: List[str]
) -> Optional[BrowseableNode]:
    """Find catalog within a hierarchy at provided path or return None."""
    try:
        for fork in split_path:
            hierarchy = next(
                node
                for node in hierarchy["children"]
                if "catalog_id" in node and node["catalog_id"] == fork
            )
        return hierarchy
    except StopIteration:
        return None


def browseable_catalog_link(
    node: BrowseableNode, base_url: str, catalog_path: str
) -> str:
    """Produce browseable link to a child."""
    return {
        "rel": Relations.child.value,
        "type": MimeTypes.json,
        "title": node.get("title") or node.get("catalog_id"),
        "href": "/".join([base_url.strip("/"), "catalogs", catalog_path.strip("/")]),
    }


def browseable_collection_link(node: BrowseableNode, base_url: str) -> str:
    """Produce browseable link to a child."""
    return {
        "rel": Relations.child.value,
        "type": MimeTypes.json,
        "title": node.get("title") or node.get("collection_id"),
        "href": urljoin(base_url, f"collections/{node['collection_id']}"),
    }


def browseable_item_link(item_path: ItemPath, base_url: str):
    """Produce browseable link to an item."""
    return {
        "rel": Relations.item.value,
        "type": MimeTypes.json,
        "href": urljoin(base_url, f"collections/{item_path[0]}/items/{item_path[1]}"),
    }


def browseable_catalog_page(
    catalog_node: CatalogNode,
    base_url: str,
    catalog_path: str,
    stac_version: str,
    conformance_classes: List[str],
    extension_schemas: List[str],
) -> stac_types.LandingPage:
    """Generate a STAC API landing page/catalog."""
    catalog_links = [
        browseable_catalog_link(
            child, base_url, "/".join([catalog_path.strip("/"), child["catalog_id"]])
        )
        for child in catalog_node["children"]
        if "catalog_id" in child
    ]
    collection_links = [
        browseable_collection_link(child, base_url)
        for child in catalog_node["children"]
        if "collection_id" in child
    ]
    children_links = catalog_links + collection_links
    item_links = [
        browseable_item_link(item, base_url) for item in catalog_node["items"]
    ]

    split_catalog_path = catalog_path.split("/")
    if len(split_catalog_path) > 1:
        parent_href = urljoin(
            base_url, f"/catalogs/{'/'.join(split_catalog_path[:-1])}"
        )
    else:
        parent_href = base_url

    standard_links = [
        {
            "rel": Relations.self.value,
            "type": MimeTypes.json,
            "href": urljoin(base_url, f"/catalogs/{catalog_path.strip('/')}"),
        },
        {
            "rel": Relations.root.value,
            "type": MimeTypes.json,
            "href": base_url,
        },
        {
            "rel": "data",
            "type": MimeTypes.json,
            "href": urljoin(
                base_url, f"/catalogs/{catalog_path.strip('/')}/collections"
            ),
        },
        {
            "rel": Relations.conformance.value,
            "type": MimeTypes.json,
            "title": "STAC/WFS3 conformance classes implemented by this api",
            "href": urljoin(
                base_url, f"/catalogs/{catalog_path.strip('/')}/conformance"
            ),
        },
        {
            "rel": Relations.search.value,
            "type": MimeTypes.geojson,
            "title": "STAC search",
            "href": urljoin(base_url, f"/catalogs/{catalog_path.strip('/')}/search"),
            "method": "GET",
        },
        {
            "rel": Relations.search.value,
            "type": MimeTypes.json,
            "title": "STAC search",
            "href": urljoin(base_url, f"/catalogs/{catalog_path.strip('/')}/search"),
            "method": "POST",
        },
        {"rel": Relations.parent.value, "type": MimeTypes.json, "href": parent_href},
    ]

    catalog_page = stac_types.LandingPage(
        type="Catalog",
        id=catalog_node["catalog_id"],
        title=catalog_node["catalog_id"],
        description=catalog_node["description"],
        stac_version=stac_version,
        conformsTo=conformance_classes,
        links=standard_links + children_links + item_links,
        stac_extensions=extension_schemas,
    )
    return catalog_page


# PGSTAC TODO: function to allow ingest of hierarchy
def parse_hierarchy(d: dict) -> BrowseableNode:
    """Parse a dictionary as a BrowseableNode tree."""
    d_items = d.get("items") or []
    d_children = d.get("children") or []
    parsed_children = [parse_hierarchy(child) for child in d_children]

    if "collection_id" in d:
        return CollectionNode(
            collection_id=d["collection_id"], children=parsed_children, items=d_items
        )
    elif "catalog_id" in d:
        return CatalogNode(
            catalog_id=d["catalog_id"],
            children=parsed_children,
            items=d_items,
            title=d.get("title"),
            description=d.get("description"),
        )
    else:
        return BrowseableNode(children=d_children, items=d_items)
