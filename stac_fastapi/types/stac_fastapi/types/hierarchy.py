"""Types and functions for browsable and children conformance class support.

The types contained in this file provide the tooling necessary to support hierarchy within a
STAC API. The various nodes are recursively parsed from a dict which can (e.g.) be generated by
json.load. A minimal, STAC compliant catalog can be generated from a catalog node (refer to a
node's id field name: it will either be catalog_id or collection_id) with the browsable_catalog
function.
"""
from typing import List, Optional, Tuple, TypedDict, Union
from urllib.parse import urljoin

from stac_pydantic import Catalog
from stac_pydantic.links import Relations
from stac_pydantic.shared import MimeTypes
from stac_pydantic.version import STAC_VERSION

ItemPath = Tuple[str, str]
NodeType = str


class BrowsableNode(TypedDict):
    """Abstract node for defining browsable hierarchy."""

    children: List[Union["CatalogNode", "CollectionNode"]]
    items: List[ItemPath]


class CollectionNode(BrowsableNode):
    """Node for collections in browsable hierarchy."""

    collection_id: str


class CatalogNode(BrowsableNode):
    """Node for collections in browsable hierarchy."""

    catalog_id: str
    title: Optional[str]
    description: Optional[str]


def browsable_catalog_link(
    node: BrowsableNode, base_url: str, catalog_path: str
) -> str:
    """Produce browsable link to a child."""
    return {
        "rel": Relations.child.value,
        "type": MimeTypes.json,
        "title": node.get("title") or node.get("catalog_id"),
        "href": "/".join([base_url.strip("/"), "catalogs", catalog_path.strip("/")]),
    }


def browsable_collection_link(node: BrowsableNode, base_url: str) -> str:
    """Produce browsable link to a child."""
    return {
        "rel": Relations.child.value,
        "type": MimeTypes.json,
        "title": node.get("title") or node.get("collection_id"),
        "href": urljoin([base_url, f"collections/{node['collection_id']}"]),
    }


def browsable_item_link(item_path: ItemPath, base_url: str):
    """Produce browsable link to an item."""
    return {
        "rel": Relations.item.value,
        "type": MimeTypes.json,
        "href": urljoin(base_url, f"collections/{item_path[0]}/items/{item_path[1]}"),
    }


def browsable_catalog(node: CatalogNode, base_url: str, catalog_path: str) -> Catalog:
    """Generate a catalog based on a CatalogNode in a BrowsableNode tree."""
    catalog_links = [
        browsable_catalog_link(
            child, base_url, "/".join([catalog_path.strip("/"), child["catalog_id"]])
        )
        for child in node["children"]
        if "catalog_id" in child
    ]
    collection_links = [
        browsable_collection_link(child, base_url)
        for child in node["children"]
        if "collection_id" in child
    ]
    children_links = catalog_links + collection_links
    item_links = [browsable_item_link(item, base_url) for item in node["items"]]

    split_catalog_path = catalog_path.split("/")
    if len(split_catalog_path) > 1:
        parent_href = urljoin(
            base_url, f"/catalogs/{'/'.join(split_catalog_path[:-1])}"
        )
    else:
        parent_href = base_url

    standard_links = [
        {
            "rel": Relations.root.value,
            "type": MimeTypes.json,
            "href": base_url,
        },
        {
            "rel": Relations.self.value,
            "type": MimeTypes.json,
            "href": urljoin(base_url, f"/catalogs/{catalog_path.strip('/')}"),
        },
        {"rel": Relations.parent.value, "type": MimeTypes.json, "href": parent_href},
    ]
    return Catalog(
        type="Catalog",
        id=node["catalog_id"],
        description=node.get("description")
        or f"Generated description for {node['catalog_id']}",
        stac_version=STAC_VERSION,
        links=children_links + item_links + standard_links,
    )


def parse_hierarchy(d: dict) -> BrowsableNode:
    """Parse a dictionary as a BrowsableNode tree."""
    d_items = d.get("items") or []
    d_children = d.get("children") or []
    parsed_children = [parse_hierarchy(child) for child in d_children]

    if "collection_id" in d:
        return CollectionNode(
            collection_id=d["collection_id"], children=parsed_children, items=d_items
        )
    elif "catalog_id" in d:
        return CatalogNode(
            catalog_id=d["catalog_id"],
            children=parsed_children,
            items=d_items,
            title=d.get("title"),
            description=d.get("description"),
        )
    else:
        return BrowsableNode(children=d_children, items=d_items)
